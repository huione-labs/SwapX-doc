# Swaps
# 介绍
SwapX 中的代币交换是一种将一个 ERC-20 代币兑换成另一个 ERC-20 代币的简单方法。

对于最终用户来说，交换是直观的：用户选择一个输入代币和一个输出代币。他们指定输入金额，协议计算他们将收到多少输出代币。然后他们只需单击一下即可执行交换，并立即在钱包中收到输出代币。

在本指南中，我们将研究协议级别的交换过程中发生的情况，以便更深入地了解 SwapX 的工作原理。

SwapX 中的掉期交易与传统平台上的交易不同。SwapX 不使用订单簿来表示流动性或确定价格。SwapX 使用自动做市商机制来提供有关费率和滑点的即时反馈。

正如我们在协议概述中了解到的，SwapX 上的每对实际上都由一个流动性池支撑。流动性池是智能合约，它持有两种独特代币的余额，并执行有关存款和取款的规则。

该规则是常数乘积公式。当提取（购买）任一代币时，必须存入（出售）一定比例的另一个代币，以保持常数。

## Anatomy of a swap
从最基本的层面上讲，SwapX V2 中的所有交换都发生在一个函数中，该函数恰如其名swap:

```
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data);
```

# Receiving tokens
从函数签名中可以清楚地看出，SwapX 要求swap调用者通过参数指定他们希望接收多少个输出代币amount{0,1}Out，这些参数对应于所需的数量token{0,1}。


# Sending Tokens
目前尚不清楚的是 SwapX 如何接收代币作为交换的付款。通常，需要代币来执行某些功能的智能合约要求调用者首先在代币合约上进行批准，然后调用一个函数，该函数反过来在代币合约上调用 transferFrom。这不是V2对接受代币的方式。相反，对在每次交互结束时检查其代币余额。然后，在下一次交互开始时，将当前余额与存储的值进行比较，以确定当前交互者发送的代币数量。请参阅白皮书以了解为什么会这样。

要点是，在调用 swap 之前必须将代币转移到对中（此规则的一个例外是Flash Swaps）。这意味着要安全地使用该函数，必须从另一个智能合约swap调用它。替代方法（将代币转移到对中然后调用）在非原子情况下是不安全的，因为发送的代币容易受到套利。
